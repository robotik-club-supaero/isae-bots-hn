![logo isae-robotics-club](../.media/isae_robotics_logo.png)

# Exécuter le code

## Prérequis :

### Les tutoriels "Téléchargement du code" et "Installation Docker"

## Ouvrir un terminal dans le Docker

Ces commandes doivent être faites dans le dossier `isae-bots-hn-2024`.
Si vous souhaitez exécuter une application graphique (telle que l'interface), vous devez d'abord exécuter la commande `xhost +`.

- Pour démarrer le conteneur Docker et ouvrir le terminal principal, utilisez la commande `make main`.
- Pour ouvrir des terminaux supplémentaires, tapez `make term`.
- Pour quitter le terminal, tapez `exit` (dans le Docker).

## Arrêter le conteneur

Pour arrêter le conteneur manuellement, on peut utiliser `docker stop isaebots`.

## Démarrer un programme ROS

Dans le Docker, faire :

```
ros2 run <package> <executable>
```

### Liste des exécutables

* #### Interface graphique :
```bash
ros2 run uix interface_node # Penser à faire `xhost +` avant d'aller dans le Docker
```

* #### Yasmin viewer
Pour visualiser la machine à états définie dans l'action_node :
```bash
ros2 run yasmin_viewer yasmin_viewer_node
```

Ensuite il faut ouvrir l'adresse qui s'affiche (généralement `http://localhost:5000`) dans un navigateur en dehors du Docker.

* #### MicroRos serial
Permet de connecter ROS2 en série à la BR, les actionneurs, etc. _Pour le lidar, voir ci-après._
```bash
ros2 run micro_ros_agent micro_ros_agent serial --dev /dev/ttyXXX
```

`ttyXXX` doit être remplacé par le nom de la carte connectée. Par défaut, le nom ressemble probablement à `ttyACM0`.
Normalement, le Raspberry est configuré pour utiliser des noms explicites, tels que `ttyBR` pour la BR, `ttyACT` pour la carte actionneurs et `ttyLIDAR` pour le lidar, mais la configuration n'est pas toujours à jour vu qu'on change souvent de carte.

Vous pouvez faire `ls /dev/tty*` (sur le Docker ou non) pour lister les périphériques connectés.

* #### Noeud du Lidar Hokuyo

```
ros2 launch urg_node2 urg_node2.launch.py
```

>Attention, c'est bien `ros2 launch` et non `ros2 run`.

Pour changer le port série, il faut modifier le fichier `dev/lib/urg_node2/config/params_serial.yaml` (dans le Docker). Par défaut, il est défini sur `ttyACM0` sur PC et `ttyLIDAR` sur le Raspberry.

Pour utiliser un lidar ethernet à la place d'un lidar série, il faut remplacer `params_serial` par `params_ether` dans `dev/lib/urg_node2/launch/urg_node2.launch.py`. L'adresse IP et le port doivent être définis dans `dev/lib/urg_node2/config/params_ether.yaml`.

* #### wiimote_node
Permet de contrôler la BR avec une manette de WII (en bluetooth).
```bash
ros2 run control wiimote_node
```

Attention, ce noeud gère uniquement la communication avec la manette de WII. Pour communiquer avec la BR, vous avez aussi besoin d'un noeud MicroRos. Un script permet d'automatiser le lancement (voir ci-dessous).

* #### La stratégie

**Le noeud de décision :**
```bash
ros2 run strat dec_node
```

**Le noeud d'action :**
```bash
ros2 run strat act_node
```

Les deux sont nécessaires en match, mais vous pouvez les lancer séparément pour faire des tests.

* #### Le pathfinder (noeud de déplacement)
```bash
ros2 run displacement disp_node
```

C'est lui qui reçoit les ordres de déplacement de la stratégie et gère l'évitement des obstacles, donc il est aussi nécessaire en match.

* #### Noeuds de simulation

    * **La BR**
    ```bash
    ros2 run br_simu simulation_br
    ```

    * **Les actionneurs**
    ```bash
    ros2 run sim actuator_node
    ```

    * **Simulation d'obstacle**
    ```bash
    ros2 run sim obstacle_node
    ```

* #### Noeuds lidar/sonar

    * #### Noeud central :
    Ce noeud centralise les données du lidar et du sonar et les envoie au noeud de déplacement. Il est nécessaire même si un seul des deux capteurs est utilisé.
    ```bash
    ros2 run sensors sensors_node
    ```

    * #### Noeud du lidar
    Nécessaire seulement si le lidar est présent
     ```bash
    ros2 run sensors lidar_node
    ```

    * #### Noeud du sonar
    Nécessaire seulement si le sonar est présent
    ```bash
    ros2 run sensors sonar_node
    ```

* #### Noeuds "top" (seulement sur le Raspberry)
    Attention, ces programmes viennent d'être migrés sous ROS2 et sont encore insuffisamment testés.

    * #### Noeud maître
    Permet de démarrer et d'arrêter automatiquement tous les noeuds nécessaires en match avec un interrupteur. Une fois que tout est configuré et testé, c'est le seul noeud à démarrer manuellement sur le Raspberry.
    ```
    ros2 run top master_node
    ```

    * #### Noeud de l'ISB
    C'est la carte qui gère la "tirette" pour démarrer le match. Elle permet aussi de choisir la stratégie, la couleur et la position de départ et d'activer l'asservissement de la BR sans passer par l'interface graphique.
    ```
    ros2 run top isb_node
    ```

    * #### Noeud de l'écran LCD
    Affiche l'estimation du score pendant un match.
    ```
    ros2 run top lcd_node
    ```

## Démarrer un script ROS

Dans le Docker, faire :

```
ros2 launch scripts/nom_du_script.launch
```

L'interface graphique est indépendante et doit être démarrée dans un autre terminal.

### Liste des scripts :

Un script ROS contient juste une liste de noeuds à exécuter. Les scripts sont dans le dossier `scripts`.

* **simulator.launch**

Démarre les programmes qui gèrent la stratégie et le pathfinder + la simulation des actionneurs et de la BR. 

```
ros2 launch scripts/simulator.launch
```

* **remote_control.launch**

Démarre le programme 

```
ros2 launch scripts/remote_control.launch BR:=/dev/ttyXXX
```

où ttyXXX est le nom de la carte BR connectée (voir plus haut la description de MicroRos).

* **match.launch**

Démarre les programmes qui gèrent la stratégie et le pathfinder + tous les autres noeuds nécessaires pour connecter les différentes parties du vrai robot. Ce script peut être utilisé uniquement sur le Raspberry.

TODO: pas encore migré sous ROS2 !